<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>about – graph envy</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Crimson+Text:ital,wght@0,400;0,600;1,400&display=swap');
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            background: #2a2a2a;
            color: #f5f5f0;
            font-family: 'Crimson Text', serif;
            height: 100vh;
            overflow: hidden;
            margin: 0;
            padding: 0;
        }
        
        #neural-canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: -1;
        }
        
        .content {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 1;
            text-align: center;
            padding: 0 20px;
            box-sizing: border-box;
            max-height: 85vh;
            overflow: hidden;
        }
        
        h1 {
            font-size: clamp(2rem, 6vw, 3.5rem);
            font-weight: 600;
            letter-spacing: 0.02em;
            text-transform: lowercase;
            text-shadow: 0 0 30px rgba(245, 245, 240, 0.3);
            word-break: keep-all;
            overflow-wrap: normal;
            text-align: left;
            max-width: min(75ch, 85vw);
            margin: 0 auto 2rem auto;
        }
        
        .about-content {
            font-size: clamp(1rem, 2.8vw, 1.2rem);
            font-weight: 400;
            letter-spacing: 0.01em;
            opacity: 0.9;
            max-width: min(75ch, 85vw);
            margin: 0 auto;
            line-height: 1.5;
            text-align: left;
        }
        
        .about-content p {
            margin-bottom: 1.2rem;
        }
        
        .about-content p:last-child {
            margin-bottom: 0;
        }
        
        .contact-link {
            color: inherit;
            text-decoration: none;
            border-bottom: 1px dotted rgba(245, 245, 240, 0.4);
            transition: all 0.3s ease;
        }
        
        .contact-link:hover {
            color: rgba(255, 162, 39, 0.8);
            border-bottom-color: rgba(255, 162, 39, 0.8);
        }
        
        @media (max-width: 768px) {
            body {
                padding: 20px 10px;
                overflow-y: auto;
                height: auto;
                min-height: 100vh;
            }
            
            .content {
                position: relative;
                top: auto;
                left: auto;
                transform: none;
                padding: 40px 10px;
                max-height: none;
                overflow: visible;
            }
            
            h1 {
                margin-bottom: 1rem;
            }
            
            .about-content {
                line-height: 1.4;
            }
            
            .about-content p {
                margin-bottom: 1rem;
            }
        }
        
        .credit {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 0.7rem;
            opacity: 0.3;
            z-index: 2;
        }
        
        .credit a {
            color: #f5f5f0;
            text-decoration: none;
            transition: opacity 0.3s ease;
        }
        
        .credit a:hover {
            opacity: 1;
        }
        
        @media (max-width: 480px) {
            h1 {
                margin-bottom: 1rem;
            }
            
            .credit {
                bottom: 15px;
                font-size: 0.6rem;
            }
        }
    </style>
</head>
<body>
    <canvas id="neural-canvas"></canvas>
    <div class="content">
        <h1>about</h1>
        <div class="about-content">
            <p>You know that feeling when someone else just <em>gets it</em> in ways you don't? When they see patterns that are invisible to you? That's not a character flaw—that's a network problem. The systems that determine whether you get the job, find decent therapy, or escape your student debt operate through hidden architectures. Some people have maps. Most of us are wandering around blind.</p>
            
            <p>We apply graph theory and AI systems to real human problems—not enterprise optimization or vanity metrics. The same mathematical frameworks that power billion-dollar companies, deployed for people trying to navigate actual life systems.</p>
            
            <p>Meanwhile, the most sophisticated analytical tools in human history optimize ad clicks while regular people can't figure out why their rent keeps rising, why good jobs seem invite-only, or why some people effortlessly build social circles while others stay isolated. Advanced AI can predict market crashes but somehow can't help you understand the hidden mechanics of your own life.</p>
            
            <p>Every complex system has discoverable patterns. Social networks, job markets, healthcare access, housing costs—they all operate according to principles that can be mapped, understood, and navigated. The gap isn't access to information. It's access to the right analytical frameworks. Network intelligence for everyone, not just the people who already have it.</p>
            
            <p>Life runs on hidden networks. We build the maps.</p>
            
            <p>Think you've found something worth mapping? <a href="mailto:hello@scriptwizards.org" class="contact-link">Let's talk</a>.</p>
        </div>
    </div>
    
    <div class="credit">
        <a href="https://scriptwizards.org/" target="_blank">© Script Wizards</a>
    </div>

    <script>
        class NeuralNetworkBackground {
            constructor() {
                this.canvas = document.getElementById('neural-canvas');
                this.ctx = this.canvas.getContext('2d');
                this.nodes = [];
                this.connections = [];
                this.ambientParticles = [];
                this.maxNodes = this.isMobile() ? 60 : 85;
                this.maxAmbientParticles = this.isMobile() ? 40 : 60;
                this.connectionDistance = this.isMobile() ? 140 : 180;
                this.animationFrameRef = null;
                
                this.resize();
                this.animate();
                
                window.addEventListener('resize', () => this.resize());
            }
            
            isMobile() {
                return window.innerWidth < 768 || /Android|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
            }
            
            resize() {
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
            }
            
            random(min, max) {
                return Math.random() * (max - min) + min;
            }
            
            distance(x1, y1, x2, y2) {
                const dx = x2 - x1;
                const dy = y2 - y1;
                return Math.sqrt(dx * dx + dy * dy);
            }
            
            createNode() {
                return {
                    x: this.random(50, this.canvas.width - 50),
                    y: this.random(50, this.canvas.height - 50),
                    vx: this.random(-0.2, 0.2),
                    vy: this.random(-0.2, 0.2),
                    size: this.random(2, 4),
                    opacity: 0,
                    targetOpacity: this.random(0.6, 1),
                    life: this.random(3000, 8000),
                    maxLife: 0,
                    pulsePhase: this.random(0, Math.PI * 2),
                    pulseSpeed: this.random(0.01, 0.025),
                    isActive: true
                };
            }
            
            createAmbientParticle() {
                return {
                    x: this.random(0, this.canvas.width),
                    y: this.random(0, this.canvas.height),
                    vx: this.random(-0.1, 0.1),
                    vy: this.random(-0.1, 0.1),
                    size: this.random(0.5, 1.5),
                    opacity: 0,
                    targetOpacity: this.random(0.1, 0.3),
                    life: this.random(5000, 12000),
                    maxLife: 0,
                    twinkle: this.random(0, Math.PI * 2),
                    twinkleSpeed: this.random(0.005, 0.015)
                };
            }
            
            updateNodes() {
                const currentTime = Date.now();
                
                this.nodes = this.nodes.filter(node => {
                    if (!node.birthTime) node.birthTime = currentTime;
                    if (!node.maxLife) node.maxLife = node.life;
                    
                    const age = currentTime - node.birthTime;
                    const lifeRatio = age / node.maxLife;
                    
                    if (lifeRatio > 1) {
                        return false;
                    }
                    
                    if (lifeRatio < 0.1) {
                        node.opacity = Math.min(node.opacity + 0.02, node.targetOpacity * (lifeRatio / 0.1));
                    } else if (lifeRatio > 0.8) {
                        const fadeRatio = (lifeRatio - 0.8) / 0.2;
                        node.opacity = node.targetOpacity * (1 - fadeRatio);
                    } else {
                        node.opacity = Math.min(node.opacity + 0.02, node.targetOpacity);
                    }
                    
                    return true;
                });
                
                if (this.nodes.length < this.maxNodes && Math.random() < 0.025) {
                    this.nodes.push(this.createNode());
                }
                
                this.nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    if (node.x < 20 || node.x > this.canvas.width - 20) {
                        node.vx *= -0.8;
                        node.x = Math.max(20, Math.min(this.canvas.width - 20, node.x));
                    }
                    if (node.y < 20 || node.y > this.canvas.height - 20) {
                        node.vy *= -0.8;
                        node.y = Math.max(20, Math.min(this.canvas.height - 20, node.y));
                    }
                    
                    node.pulsePhase += node.pulseSpeed;
                });
            }
            
            updateAmbientParticles() {
                const currentTime = Date.now();
                
                this.ambientParticles = this.ambientParticles.filter(particle => {
                    if (!particle.birthTime) particle.birthTime = currentTime;
                    if (!particle.maxLife) particle.maxLife = particle.life;
                    
                    const age = currentTime - particle.birthTime;
                    const lifeRatio = age / particle.maxLife;
                    
                    if (lifeRatio > 1) {
                        return false;
                    }
                    
                    if (lifeRatio < 0.2) {
                        particle.opacity = Math.min(particle.opacity + 0.01, particle.targetOpacity * (lifeRatio / 0.2));
                    } else if (lifeRatio > 0.7) {
                        const fadeRatio = (lifeRatio - 0.7) / 0.3;
                        particle.opacity = particle.targetOpacity * (1 - fadeRatio);
                    } else {
                        particle.opacity = Math.min(particle.opacity + 0.01, particle.targetOpacity);
                    }
                    
                    return true;
                });
                
                if (this.ambientParticles.length < this.maxAmbientParticles && Math.random() < 0.02) {
                    this.ambientParticles.push(this.createAmbientParticle());
                }
                
                this.ambientParticles.forEach(particle => {
                    particle.x += particle.vx;
                    particle.y += particle.vy;
                    
                    if (particle.x < 0) particle.x = this.canvas.width;
                    if (particle.x > this.canvas.width) particle.x = 0;
                    if (particle.y < 0) particle.y = this.canvas.height;
                    if (particle.y > this.canvas.height) particle.y = 0;
                    
                    particle.twinkle += particle.twinkleSpeed;
                });
            }
            
            updateConnections() {
                this.connections = [];
                
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const node1 = this.nodes[i];
                        const node2 = this.nodes[j];
                        const dist = this.distance(node1.x, node1.y, node2.x, node2.y);
                        
                        if (dist < this.connectionDistance) {
                            const strength = 1 - (dist / this.connectionDistance);
                            const opacity = Math.min(node1.opacity, node2.opacity) * strength * 0.6;
                            
                            if (Math.random() < 0.7) {
                                this.connections.push({
                                    node1,
                                    node2,
                                    opacity,
                                    strength,
                                    pulseOffset: Math.random() * Math.PI * 2
                                });
                            }
                        }
                    }
                }
            }
            
            drawConnections() {
                this.connections.forEach(connection => {
                    const { node1, node2, opacity, strength, pulseOffset } = connection;
                    
                    const pulse = 0.5 + 0.5 * Math.sin(Date.now() * 0.002 + pulseOffset);
                    const lineWidth = 1 + strength * 2.5 * pulse;
                    const alpha = opacity * (0.8 + 0.5 * pulse);
                    
                    this.ctx.beginPath();
                    this.ctx.strokeStyle = `rgba(245, 245, 240, ${alpha})`;
                    this.ctx.lineWidth = lineWidth;
                    this.ctx.moveTo(node1.x, node1.y);
                    this.ctx.lineTo(node2.x, node2.y);
                    this.ctx.stroke();
                    
                    if (strength > 0.7 && Math.random() < 0.05) {
                        const midX = (node1.x + node2.x) / 2;
                        const midY = (node1.y + node2.y) / 2;
                        
                        this.ctx.beginPath();
                        this.ctx.fillStyle = `rgba(245, 245, 240, ${alpha * 2})`;
                        this.ctx.arc(midX, midY, 1, 0, Math.PI * 2);
                        this.ctx.fill();
                    }
                });
            }
            
            drawNodes() {
                this.nodes.forEach(node => {
                    const pulse = 0.7 + 0.3 * Math.sin(node.pulsePhase);
                    const currentSize = node.size * pulse;
                    
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(245, 245, 240, ${node.opacity})`;
                    this.ctx.arc(node.x, node.y, currentSize, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(245, 245, 240, ${node.opacity * 0.2})`;
                    this.ctx.arc(node.x, node.y, currentSize * 2, 0, Math.PI * 2);
                    this.ctx.fill();
                    
                    const connectionCount = this.connections.filter(c => 
                        c.node1 === node || c.node2 === node
                    ).length;
                    
                    if (connectionCount > 3 && Math.random() < 0.02) {
                        this.ctx.beginPath();
                        this.ctx.strokeStyle = `rgba(245, 245, 240, ${node.opacity * 0.8})`;
                        this.ctx.lineWidth = 1;
                        this.ctx.arc(node.x, node.y, currentSize * 3, 0, Math.PI * 2);
                        this.ctx.stroke();
                    }
                });
            }
            
            drawAmbientParticles() {
                this.ambientParticles.forEach(particle => {
                    const twinkleOpacity = particle.opacity * (0.5 + 0.5 * Math.sin(particle.twinkle));
                    
                    this.ctx.beginPath();
                    this.ctx.fillStyle = `rgba(245, 245, 240, ${twinkleOpacity})`;
                    this.ctx.arc(particle.x, particle.y, particle.size, 0, Math.PI * 2);
                    this.ctx.fill();
                });
            }
            
            animate() {
                this.ctx.fillStyle = '#2a2a2a';
                this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
                
                this.updateAmbientParticles();
                this.updateNodes();
                this.updateConnections();
                this.drawAmbientParticles();
                this.drawConnections();
                this.drawNodes();
                
                this.animationFrameRef = requestAnimationFrame(() => this.animate());
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new NeuralNetworkBackground();
        });
    </script>
</body>
</html> 
